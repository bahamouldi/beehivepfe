import logging
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse, PlainTextResponse
from waf.rules import check_regex_rules, list_rules
from waf.anomaly import AnomalyDetector
from waf.clamav_scanner import scan_bytes
from waf.ratelimit import RateLimiter
import asyncio

# Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger('beewaf')

app = FastAPI(title="BeeWAF")

# Components
detector = AnomalyDetector()
rate_limiter = RateLimiter()


@app.on_event("startup")
async def startup_event():
    loop = asyncio.get_event_loop()
    await loop.run_in_executor(None, detector.train)
    logger.info('Anomaly detector training started')


def _client_id_from_request(request: Request) -> str:
    # prefer X-Real-IP or X-Forwarded-For to support proxies; fallback to peername
    headers = request.headers
    xreal = headers.get('x-real-ip') or headers.get('x-forwarded-for')
    if xreal:
        return xreal.split(',')[0].strip()
    client = request.client
    if client and client.host:
        return client.host
    return 'unknown'


@app.middleware("http")
async def waf_middleware(request: Request, call_next):
    body_bytes = await request.body()
    try:
        body_text = body_bytes.decode('utf-8', errors='ignore')
    except Exception:
        body_text = ''
    path = request.url.path
    headers = dict(request.headers)

    # rate limit check
    client_id = _client_id_from_request(request)
    allowed, remaining = rate_limiter.allow_request(client_id)
    if not allowed:
        logger.warning('Rate limit exceeded: %s', client_id)
        return JSONResponse({"blocked": True, "reason": "rate-limit"}, status_code=429)

    # regex rules
    bad, reason = check_regex_rules(path, body_text, headers)
    if bad:
        logger.info('Blocked by regex rule: %s %s %s', client_id, path, reason)
        return JSONResponse({"blocked": True, "reason": reason}, status_code=403)

    # anomaly detection
    features = detector.vectorize(path, headers, body_text)
    if detector.is_anomaly(features):
        logger.info('Blocked by anomaly detection: %s %s', client_id, path)
        return JSONResponse({"blocked": True, "reason": "anomaly-detection"}, status_code=403)

    # clamav scan
    infected, meta = scan_bytes(body_bytes)
    if infected:
        logger.info('Blocked by clamav: %s %s %s', client_id, path, meta)
        return JSONResponse({"blocked": True, "reason": "clamav-detected", "meta": meta}, status_code=403)

    async def receive():
        return {"type": "http.request", "body": body_bytes}

    request._receive = receive
    response = await call_next(request)
    return response


@app.get("/health")
async def health():
    return {
        "status": "ok",
        "anomaly_detector_trained": bool(detector.trained),
        "rules_count": len(list_rules()),
    }


@app.get("/admin/rules")
async def admin_rules():
    return {"rules": list_rules()}


@app.post("/echo")
async def echo(request: Request):
    body = await request.body()
    return PlainTextResponse(body)


@app.get("/")
async def index():
    return {"service": "BeeWAF", "status": "running"}
